---
sidebar_position: 4
description: 2023.9.11 腾讯 TEG AI Lab 一面
tags:
  - 面试经验
---

## Vue
- `KeepAlve` 到底缓存/记录的是什么？
   - Vue.js 中的 `<keep-alive>` 组件是用来缓存和重新渲染组件的工具。它不会记录滚动的高度或其他视觉属性，而是缓存组件的状态、DOM结构以及组件的实例，以便在组件被再次渲染时可以保留之前的状态。具体来说，`<keep-alive>` 会在组件被切换出去时将其状态保存在内存中，以避免每次切换到该组件时都重新创建和初始化。这可以提高性能，特别是在包含大量数据或复杂计算的组件中。
- `nextTick` 为什么可以获取到最新的DOM
   - nextTick 是 Vue.js 提供的一个方法，用于在 DOM 更新之后执行回调函数。它的主要作用是等待 Vue 实例更新 DOM，并在更新完成后执行回调。这使得您可以在更新后访问最新的 DOM 元素。Vue 使用异步队列来处理 DOM 更新。当您修改 Vue 数据时，Vue 不会立即更新 DOM，而是将更新放入一个队列中，然后异步处理这个队列，以提高性能和效率。这就是为什么在某些情况下，当您修改数据后立即尝试访问新的 DOM 元素时，您可能会得到旧的 DOM 状态，因为更新尚未应用。
- `setup` 这个语法糖，他是什么时候执行的，`create/beforeCreate` 之前还是之后
   - setup 是 Vue 3 中的语法糖，用于配置组件的设置和响应式数据，它是在组件实例创建之前执行的，也就是在 beforeCreate 和 created 钩子之前执行。
   - ![生命周期图示](https://cn.vuejs.org/assets/lifecycle.16e4c08e.png)

## React
- React 自定义 hook 编写有什么注意点，如果它里面使用到了 `useEffect` 这种，会不会造成什么影响，比如说内存泄漏什么的？
   - 在编写自定义 React Hook 时，有一些注意点需要考虑，特别是涉及到 useEffect 时，以避免潜在的问题，如内存泄漏。以下是一些关于编写自定义 Hook 的一些建议和注意点：
      - **命名规范**：自定义 Hook 应以 "use" 开头，这是 React 社区的约定，以便开发者知道它是一个 Hook。
      - **复用逻辑**：自定义 Hook 的主要目的是为了复用一些组件之间的逻辑，确保您将通用的逻辑抽取到 Hook 中，以便多个组件可以共享。
      - **只在顶层使用 Hook**：不要在条件语句、循环或嵌套函数中调用 Hook，它应该总是在 React 函数组件的顶层调用。这有助于 React 正确地跟踪 Hook 的状态。
      - **依赖项数组**：在使用 useEffect 时，确保传递正确的依赖项数组。这有助于避免不必要的重复执行和潜在的内存泄漏。如果不传递依赖项数组，它将在每次组件渲染时都执行。
      - **清理副作用**：如果自定义 Hook 中使用了 useEffect 来创建副作用，确保在组件卸载或下一次副作用执行之前进行清理，以避免内存泄漏。您可以返回一个清理函数，React 会在组件卸载时调用它。
      - **测试**：编写测试以确保您的自定义 Hook 行为正确，并覆盖各种用例。
      - **文档和类型**：为您的自定义 Hook 编写清晰的文档，并使用 TypeScript 或 PropTypes 来添加类型检查。
      - **小心 Hook 副作用**：避免在 Hook 中做过多的副作用操作，尤其是在渲染频率较高的组件中。尽量将副作用操作保持干净和高效。
   - 关于 useEffect，它本身并不会导致内存泄漏。内存泄漏通常是由于未正确清理副作用引起的。确保在自定义 Hook 中的 useEffect 中返回清理函数，以及在组件卸载时执行清理操作，可以有效地避免内存泄漏问题。

## JavaScript
- JS 事件机制：是不是所有事件都有冒泡？哪些事件没有冒泡？
   - JavaScript 中的事件机制包括冒泡（bubbling）和捕获（capturing）两个阶段。大多数事件都会在这两个阶段中冒泡，但并不是所有事件都具有冒泡特性。以下是一些常见的事件类型和它们是否具有冒泡特性的情况：
      - 有冒泡的事件：
         - 点击事件（click）
         - 鼠标移动事件（mousemove）
         - 键盘事件（keydown、keyup）
         - 表单事件（submit、reset、input）
         - 焦点事件（focus、blur）
         - 复制事件（copy）
         - 粘贴事件（paste）
         - 拖拽事件（drag、dragstart、dragend）
         - 等等
      - 没有冒泡的事件：
         - focusin 和 focusout 事件：这些事件在捕获阶段触发，不冒泡。
         - mouseenter 和 mouseleave 事件：与 mouseover 和 mouseout 不同，这些事件不冒泡。
         - scroll 事件：滚动事件不会冒泡，但您可以在包含滚动内容的容器上监听它。
         - load 事件：load 事件用于图片、音频和其他资源的加载，通常不会冒泡。
   - 需要注意的是，并不是所有事件都会冒泡，但大多数常见的用户交互事件（如点击、键盘输入、鼠标移动等）都会冒泡。这使得您可以在 DOM 树的层次结构中的不同元素上捕获和处理事件，从而实现更灵活的交互行为。
   - 如果您想要阻止事件冒泡，可以使用事件对象的 stopPropagation 方法。这可以防止事件继续在 DOM 树上冒泡传播到更高级的元素。
- ........

## 项目
- 低代码，难点
- 假如说要加入个组件属性联动的效果，如何做？
- 怎么做打包部署的？
- 构建工具用的Vite，为什么快？
